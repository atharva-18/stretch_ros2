// This is a test script to demonstrate replanning for the Stretch RE1 robot

#include <moveit/move_group_interface/move_group_interface.h>
#include <moveit/planning_scene_interface/planning_scene_interface.h>
#include <moveit_msgs/msg/display_robot_state.hpp>
#include <moveit_msgs/msg/display_trajectory.hpp>
#include <moveit_msgs/msg/attached_collision_object.hpp>
#include <moveit_msgs/msg/collision_object.hpp>
#include <moveit_visual_tools/moveit_visual_tools.h>

#include <geometry_msgs/msg/transform_stamped.hpp>
#include <tf2_ros/transform_listener.h>
#include <tf2_ros/buffer.h>
#include <math.h>


static const rclcpp::Logger LOGGER = rclcpp::get_logger("replanning_demo");

// Replanning(){
//   // // This is the constructor that sets up the attributes for Replanning class
//   // __init__():
//   //   pass
//   // // This method accepts the final state of the robot as input from the user
//   // // input: goal state in the form of MoveIt joint_group_positions
//   // // output: calls plan() to begin planning and execution
//   // get_state():
//   //   pass  
//   // // This method plans the joint trajectories using MoveIt
//   // // input: current state and goal state
//   // // output: calls execute with MoveIt generated trajectories
//   // plan():
//   //   pass
//   // // This method executes the plan generated by MoveIt
//   // // input: MoveIt generated trajectories
//   // // output: 
//   // execute():
//   //   pass    
//   // // This method computes the error in odom and base_link tf frames and generate the input for replanning
//   // // input: goal state of the base
//   // // output: difference between odom and base_link as goal state passed to plan()
//   // compute_error():
//   //   pass
//   // // This method runns the loop for replanning
//   // // input:
//   // // output:
//   // main():
//   //   pass
// }

int main(int argc, char** argv)
{
  rclcpp::init(argc, argv);
  rclcpp::NodeOptions node_options;
  node_options.automatically_declare_parameters_from_overrides(true);

  std::shared_ptr<tf2_ros::TransformListener> transform_listener_{nullptr};
  std::unique_ptr<tf2_ros::Buffer> tf_buffer_;

  auto move_group_node = rclcpp::Node::make_shared("replanning_demo", node_options);

  rclcpp::executors::SingleThreadedExecutor executor;
  executor.add_node(move_group_node);
  std::thread([&executor]() { executor.spin(); }).detach();

  tf_buffer_ = std::make_unique<tf2_ros::Buffer>(move_group_node->get_clock());
  transform_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);

  static const std::string PLANNING_GROUP_BASE_ARM = "mobile_base_arm";

  moveit::planning_interface::MoveGroupInterface move_group(move_group_node, PLANNING_GROUP_BASE_ARM);
  moveit::planning_interface::PlanningSceneInterface planning_scene_interface;

  const moveit::core::JointModelGroup* joint_model_group =
      move_group.getCurrentState()->getJointModelGroup(PLANNING_GROUP_BASE_ARM);
  const moveit::core::LinkModel* ee_parent_link = 
      move_group.getCurrentState()->getLinkModel("base_link"); // the link name can be changed here to visualize the trajectory of the corresponding link

  namespace rvt = rviz_visual_tools;
  moveit_visual_tools::MoveItVisualTools visual_tools(move_group_node, "odom", "move_group_visualization",
                                                      move_group.getRobotModel());
  visual_tools.deleteAllMarkers();
  visual_tools.loadRemoteControl();

  visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to start the demo");
  visual_tools.trigger();

  moveit::planning_interface::MoveGroupInterface::Plan my_plan;

  moveit::core::RobotStatePtr current_state = move_group.getCurrentState(10);
  std::vector<double> joint_group_positions;
  current_state->copyJointGroupPositions(joint_model_group, joint_group_positions);

  double desired_x = 0.5;
  double desired_y = 0;
  double desired_theta = 0; //1.57;
  double error = 10; // euclidean distance error metric
  double threshold = 0.05;
  int max_iterations = 3;
  int iteration = 1;

  joint_group_positions[0] = desired_x;
  joint_group_positions[1] = desired_y;
  joint_group_positions[2] = desired_theta;
  joint_group_positions[3] = 0.2;
  joint_group_positions[4] = 0;
  joint_group_positions[5] = 0;
  joint_group_positions[6] = 0;
  joint_group_positions[7] = 0;
  joint_group_positions[8] = 229;
  move_group.setJointValueTarget(joint_group_positions);

  move_group.setMaxVelocityScalingFactor(0.8);
  move_group.setMaxAccelerationScalingFactor(0.8);

  bool success = (move_group.plan(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);
  RCLCPP_INFO(LOGGER, "Visualizing plan (joint space goal) %s", success ? "" : "FAILED");

  // Visualize the plan in RViz:
  visual_tools.deleteAllMarkers();
  visual_tools.publishTrajectoryLine(my_plan.trajectory_, ee_parent_link, joint_model_group);
  visual_tools.trigger();
  visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to continue the demo");
  
  move_group.move();
  geometry_msgs::msg::TransformStamped transformStamped;

  while((error > threshold) && (iteration <= max_iterations)){
  // while(false){

    transformStamped = tf_buffer_->lookupTransform(
              "odom", "base_link", // target frame followed by source frame
              tf2::TimePointZero);
    error = sqrt(pow((desired_x - transformStamped.transform.translation.x), 2) + pow((desired_y - transformStamped.transform.translation.y), 2));

    RCLCPP_INFO(LOGGER, "error is: %f", error);
    RCLCPP_INFO(LOGGER, "transformStamped.transform.translation.x is: %f", transformStamped.transform.translation.x);
    RCLCPP_INFO(LOGGER, "joint_group_positions[0] is: %f", joint_group_positions[0]);

    // Quaternion to Euler conversion
    tf2::Quaternion q(
        transformStamped.transform.rotation.x,
        transformStamped.transform.rotation.y,
        transformStamped.transform.rotation.z,
        transformStamped.transform.rotation.w);
    tf2::Matrix3x3 m(q);
    
    double roll, pitch, yaw;
    m.getRPY(roll, pitch, yaw);

    double updated_x = desired_x - transformStamped.transform.translation.x;
    double updated_y = desired_y - transformStamped.transform.translation.y;
    double updated_theta = desired_theta - yaw;

    joint_group_positions[0] += updated_x;
    joint_group_positions[1] += updated_y;
    joint_group_positions[2] += updated_theta;
    move_group.setJointValueTarget(joint_group_positions);

    move_group.move();

    transformStamped = tf_buffer_->lookupTransform(
              "odom", "base_link", // target frame followed by source frame
              tf2::TimePointZero);

    RCLCPP_INFO(LOGGER, "transformStamped.transform.translation.x is: %f", transformStamped.transform.translation.x);
    RCLCPP_INFO(LOGGER, "transformStamped.transform.translation.y is: %f", transformStamped.transform.translation.y);
    iteration++;
  }

  /********************************* With Obstacle *************************************/
  // // Add obstacle in the planning scene here
  // moveit_msgs::msg::CollisionObject collision_object_1_;
  // shape_msgs::msg::SolidPrimitive box_1_;
  // geometry_msgs::msg::Pose box_pose_;

  // collision_object_1_.header.frame_id = "odom";
  // collision_object_1_.id = "box1";
  
  // box_1_.type = box_1_.BOX;
  // box_1_.dimensions = { 0.1, 0.1, 0.1 };

  // box_pose_.position.x = 0.5;
  // box_pose_.position.y = 0.1;
  // box_pose_.position.z = 0.1;

  // collision_object_1_.primitives.push_back(box_1_);
  // collision_object_1_.primitive_poses.push_back(box_pose_);
  // collision_object_1_.operation = collision_object_1_.ADD;

  // std::vector<moveit_msgs::msg::CollisionObject> collision_objects;
  // collision_objects.push_back(collision_object_1_);

  // RCLCPP_INFO(LOGGER, "Add object into the world");
  // planning_scene_interface.addCollisionObjects(collision_objects);

  // // Supply next waypoint
  // desired_x = 1.2;
  // iteration = 0;
  // error = sqrt(pow((desired_x - transformStamped.transform.translation.x), 2) + pow((desired_y - transformStamped.transform.translation.y), 2));
  // joint_group_positions[0] = desired_x;
  // move_group.setJointValueTarget(joint_group_positions);

  // success = (move_group.plan(my_plan) == moveit::planning_interface::MoveItErrorCode::SUCCESS);
  // RCLCPP_INFO(LOGGER, "Visualizing plan (joint space goal) %s", success ? "" : "FAILED");

  // // Visualize the updated plan in RViz:
  // visual_tools.deleteAllMarkers();
  // visual_tools.publishTrajectoryLine(my_plan.trajectory_, ee_parent_link, joint_model_group);
  // visual_tools.trigger();
  // visual_tools.prompt("Press 'next' in the RvizVisualToolsGui window to continue the demo");
  
  // move_group.move();

  // // Replan
  // while((error > threshold) && (iteration <= max_iterations)){
  // // while(false){

  //   transformStamped = tf_buffer_->lookupTransform(
  //             "odom", "base_link", // target frame followed by source frame
  //             tf2::TimePointZero);
  //   error = sqrt(pow((desired_x - transformStamped.transform.translation.x), 2) + pow((desired_y - transformStamped.transform.translation.y), 2));

  //   RCLCPP_INFO(LOGGER, "error is: %f", error);
  //   RCLCPP_INFO(LOGGER, "transformStamped.transform.translation.x is: %f", transformStamped.transform.translation.x);
  //   RCLCPP_INFO(LOGGER, "joint_group_positions[0] is: %f", joint_group_positions[0]);

  //   // Quaternion to Euler conversion
  //   tf2::Quaternion q(
  //       transformStamped.transform.rotation.x,
  //       transformStamped.transform.rotation.y,
  //       transformStamped.transform.rotation.z,
  //       transformStamped.transform.rotation.w);
  //   tf2::Matrix3x3 m(q);
    
  //   double roll, pitch, yaw;
  //   m.getRPY(roll, pitch, yaw);

  //   double updated_x = desired_x - transformStamped.transform.translation.x;
  //   double updated_y = desired_y - transformStamped.transform.translation.y;
  //   double updated_theta = desired_theta - yaw;

  //   joint_group_positions[0] += updated_x;
  //   joint_group_positions[1] += updated_y;
  //   joint_group_positions[2] += updated_theta;
  //   move_group.setJointValueTarget(joint_group_positions);

  //   move_group.move();

  //   transformStamped = tf_buffer_->lookupTransform(
  //             "odom", "base_link", // target frame followed by source frame
  //             tf2::TimePointZero);

  //   RCLCPP_INFO(LOGGER, "transformStamped.transform.translation.x is: %f", transformStamped.transform.translation.x);
  //   RCLCPP_INFO(LOGGER, "transformStamped.transform.translation.y is: %f", transformStamped.transform.translation.y);
  //   iteration++;
  // }
  /********************************* With Obstacle *************************************/
  
  visual_tools.deleteAllMarkers();
  visual_tools.trigger();

  rclcpp::shutdown();
  return 0;
}